#include<bits/stdc++.h>
using namespace std;
/*
 分析题目 三个正整数ABC，始终满足A<B<C 且题目要求的是输入三个数 以及三个大写字母ABC 表示所需顺序
那么我们现在要建议的是字母ABC和数字ABC的对应关系。才能正确输出，并且程序能识别ABC顺序给出排列后的结果

那么根据我们分析，我们分析的关键词是识别，识别就是if。而对应关系的话就是赋值且排序->但是这里字符是不能赋予数字，因此我们自己知道对应的关系就行,毕竟最终实现也不需要这个对应关系。
*/


/* 
这道题目我最开始写错的原因是用char定义数组 然后用if去判断(if(b=="ABC"))，但这个是不对的，因为b是数组的地址,我们可以用字符串的函数strcmp去比较，或者像我现在这样改用string
*/


/* int a[4];
string b;

int main()
{
    for (int i = 1; i < 4;i++)
    {
        cin >> a[i];
    }
    cin >> b;


    sort(a + 1, a + 4);

    if(b=="ABC")
    {
        cout << a[1] << " " << a[2] << " " << a[3];
    }
    if(b=="ACB")
    {
        cout << a[1] << " " << a[3] << " "<<a[2];
    }
    if(b=="BAC")
    {
        cout << a[2] << " " << a[1] << " " << a[3];
    }
    if(b=="BCA")
    {
        cout << a[2] << " " << a[3] << " " << a[1];
    }
    if(b=="CBA")
    {
        cout << a[3] << " " << a[2] << " " << a[1];
    }
    if(b=="CAB")
    {
        cout << a[3] << " " << a[1] << " " << a[2];
    }
    return 0;
} */
// 这是我原来的写法，我之前因为不知道这个字母和数字怎么对应，所以写的又臭又长哈哈哈，但是我现在知道了一个字符映射的关系(ASCII码)A-'A'=0,B-'A'=1,C-'C'=2。
//字母的ASCII码都是递增的，同理可以用于小写字母上
//这个时候就很简单了 定义一个数组，然后进行一个排序，为什么排序，因为ASCII码是递增的嘛，又因为题目说A<B<C，所以可以知道是一个升序，这个时候存储数字的数组也升序就对应起来了。

#include<bits/stdc++.h>
using namespace std;
int i, j, k;
char a, b, c;
int main()
{
    cin >> i >> j >> k >> a >> b >> c;
    int O[3] = {i, j, k};
    sort(O, O + 3);
    cout << O[a - 'A'] << " " << O[b - 'A'] <<" " << O[c - 'A'];
    return 0;//刚才提交上去我还在想哪里错了。原来是return的位置放到69去了 哈哈哈。 
}
